# Table of contents
1. [Overview](#Overview)
1. [Build procedure](#BuildProcedure)
1. [Sysroot deployment](#SysrootDeployment)
1. [Config file change procedure](#ConfigFileChangeProcedure)
1. [Package updates](#PackageUpdates)
1. [Managing changes from upstream](#ManagingChangesFromUpstream)
1. [Buildroot tips](#BuildrootTips)
1. [Sysroot for raspberry pi](#SysrootForRaspberryPi)
___

<a name="Overview"></a>
## Overview

The `distro-main` repo is a subset of branches and tags from the buildroot
source at
[github](git://git.buildroot.net/buildroot).

**Buildroot** is the tool that generates root filesystems that are deployed
on various targets such as the CM and SM hosts.

There is extensive documentation about buildroot at
[the buildroot manual](https://buildroot.org/downloads/manual/manual.html).

Buildroot.org releases on a fairly schedule using date-stamped tags,
e.g.  `2018.11`.  Re-releases within the same month have an additional
incrementally increasing version.  For example, `2018.11.1` is the
second release in November 2018.

Local `distro-main` changes to buildroot occur on branches of these
upstream tagged releases, e.g. `cb-2018.11` is based on the upstream
tag `2018.11`.

<a name="BuildProcedure"></a>
## Build procedure

Configuration is managed by `.config` files, e.g.:

```
cerebras,buildroot_cm.config
cerebras,buildroot_sm.config
cerebras,buildroot_sm_dev.config
```

Select the configfile to build, then:

```bash
cp ${configfile} .config
make
```

<a name="SysrootDeployment"></a>
## Sysroot deployment

Downstream components (e.g. platform) use the same toolchain that is
used to build packages in buildroot.  The downstream components also
use the sysroot generated by buildroot, and so sysroot must be made
available in a location that is reachable on all build hosts.

Following a build, sysroot is located in:

```bash
output/host/<tuple>/sysroot
```

After a build, determine whether sysroot has changes that are required
by downstream users.  Examples of changes that require redeploying
sysroot include:

* changes to library version
* new header or library files

Sysroots are versioned like any other product.  The convention for naming
sysroot is:

```bash
sysroot-${branch}-${datestamp}
```
    
Copy the new sysroot to the platform buildtools directory.  E.g.:

```bash
BRANCH=cb-2018.11
DATESTAMP=$(date +%Y.%m.%d)
XTOOLVER=linaro-7.3.1-2018.05-x86_64_aarch-linux-gnu
TOOLS_HOME=/cb/platform/buildtools/x86_64-tools/aarch64/${XTOOLVER}
SYSROOT=${TOOLS_HOME}/sysroot-${BRANCH}-${DATESTAMP}
cp -a output/aarch64-buildroot-linux-gnu/sysroot ${SYSROOT}
```

Downstream makefiles (such as in platform) should be updated to reflect
the change to the sysroot path.

Note that the SM and CM sysroots are different.  And, if/when `dev`
style builds arise, those too may expose increasing divergence.
These differences may have an impact on build correctness.
Managing these differences is TBD.

<a name="ConfigFileChangeProcedure"></a>
## Config file change procedure

Config files are independant of each other, i.e. there is no concept
of a common config file though CM was originally based on SM.  Meaning,
when a change is needed for all configurations, each must be updated
in turn.

Changing a config file starts by copying the config file to `.config`.
Do not edit config files directly.  Instead, use one of the config
editors described at the
[quick start guide](https://buildroot.org/downloads/manual/manual.html#_buildroot_quick_start).

For example:

```bash
cp cerebras,buildroot_sm.config .config
make menuconfig
```

When satisfied with the changes, select `save`, then `exit`.

After building and testing the changes, copy the new config file
back to the original file and commit:

```bash
cp .config cerebras,buildroot_sm.config
git add cerebras,buildroot_sm.config
git commit
```

Repeat the same process for all config files as needed.

Run `make clean` between each iteration.

<a name="PackageUpdates"></a>
## Package updates

Packages are found in the `packages` directory.  Each contains at least:

* Config.in: describes how the package appears in the menu configuration
  including the package description, its dependencies on other packages,
  and more.

* package.mk: the buildroot makefile that orchestrates the build

* package.hash: checksums for the source files.

See 
[the manual](https://buildroot.org/downloads/manual/manual.html#_package_directory)
for a more complete description of these files.

Small changes to packages should be made by either selectively copying
updated upstream code if its available, or making custom, local-only
changes.

If the packages themselves need changing, they should be made by
using patch files.  All files ending in `.patch` are applied before
the build of that package.  Order usually matters, so select a name
that is lexically after the other patches.

<a name="ManagingChangesFromUpstream"></a>
## Managing changes from upstream

Major upgrades to new releases takes some time and effort, and so
this procedure should be taken only when there are significant
enough upstream changes to warrent the effort.

1.  Pull the new tag from upstream

1.  Create a branch from the new release tag using the following
    naming convention: `cb-${upstream_tag}`

1.  Rebase the changes from the previous branch onto
    the new branch.  Repair as needed.

<a name="BuildrootTips"></a>
## Buildroot tips

Buildroot is not `make` -- it is not particularly intelligent with respect
to changes in the package files.  For example if you add a patch file
or modify the .mk file, buildroot will not know that package needs to be
rebuilt.  Nor does it know to rebuild a package when one of its upstream
dependencies is rebuilt.  The dependencies defined in Config.in address
only build order.

Adding packages to the config file usually build properly on top
of an already-existing build.  Deleting packages from the config
file do not build properly; or more accurately, the output/target
directory will not be updated (no files are removed) to reflect
that package removal.  A more complete discussion of this topic
can be found in the
[buildroot manual](https://buildroot.org/downloads/manual/manual.html#faq-no-binary-packages).

You can rerun stages of a build by removing the semaphores that are
created at the end of each build stage.  Removing one of the semaphores
will trigger a rerun of that stage and those that follow.
The semaphores are of the format `target/build/${package}/.stamp_${stage}`.

Available stages are:

```
downloaded
extracted
patched
configured
built
target_installed
```

To address the problem that package removal does not clean up
output/target, the workaround is:

```bash
rm -rf output/target
rm -f output/build/*/.stamp_target_installed
make
```

<a name="SysrootForRaspberryPi"></a>
## Sysroot for raspberry pi

Buildroot did at one time build the sysroot for the Raspberry Pi.
That is no longer the correct procedure because it was found the
toolchain did not match that which built the RPI, and the buildroot
packages did not match those that are installed on the RPI.
The following procedure for creating the RPI sysroot is included here
only because of this historical connection to the old procedure.

Sysroot is now collected from a running RPI.  This method is
based on the "headers and libraries" section described
[here](https://medium.com/@zw3rk/making-a-raspbian-cross-compilation-sdk-830fe56d75ba).

Run this on a host that has ssh/rsync access to the RPI host:

```bash
#!/bin/bash

rpihost=172.29.40.212

sysroot=sysroot-raspbian-9

dirs=(
    /usr/lib/arm-linux-gnueabihf
    /usr/lib/gcc/arm-linux-gnueabihf
    /usr/include
    /lib/arm-linux-gnueabihf
)

rm -rf ${sysroot}
mkdir -p ${sysroot}

for dir in ${dirs[*]}
do
    rsync -rzLR --safe-links root@${rpihost}:${dir} ${sysroot}/
done
```

The RPI host may not have all necessary -dev packages installed.
This is significant because required library `.so` symlinks will
not exist, and so basic compiling/linking against those libraries
can fail.

One example of a missing `.so` symlink is `libcrypto`.  To repair
this symlink:

```bash
ln -nfs libcrypto.so.1.0.2 ${sysroot}/usr/lib/arm-linux-gnueabihf/libcrypto.so
```

Now copy the sysroot to the platform buildtools directory:

```bash
XTOOLVER=linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf
TOOLS_HOME=/cb/platform/buildtools/x86_64-tools/arm/${XTOOLVER}
cp -a ${sysroot} ${TOOLS_HOME}
```

Note: the exact version of `XTOOLVER` is a best-guess effort
based on the release date of version of Raspbian running on
`${rpihost}` and the release date of the nearest linaro toolchain
that preceeds the Rasbian release date.

Downstream makefiles (such as in platform) should be updated to reflect
the change to the sysroot path.
